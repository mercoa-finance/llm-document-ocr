// https://github.com/electrovir/pdf-text-reader
// MIT License

import { getDocument } from "pdfjs-dist/legacy/build/pdf";
import {
  DocumentInitParameters,
  PDFDataRangeTransport,
  PDFPageProxy,
  TextItem,
  TypedArray,
} from "pdfjs-dist/types/src/display/api";

export type Page = {
  lines: string[][];
};

export type ProgressData = {
  loaded: number;
  total: number;
};

/**
 * Read a pdf file and convert it into lines of text.
 *
 * If a URL is used to fetch the PDF data a standard XMLHttpRequest(XHR) is used, which means it
 * must follow the same origin rules that any XHR does e.g. No cross domain requests without CORS.
 *
 * Parameter documentation copied from getDocument's documentation in
 * https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/pdfjs-dist/index.d.ts
 *
 * @param source Url or path as a string or other data types as seen in type below
 * @param pdfDataRangeTransport Used if you want to manually server range requests for data in the
 *   PDF. @ee viewer.js for an example of pdfDataRangeTransport's interface.
 * @param passwordCallback Used to request a password if wrong or no password was provided. The
 *   callback receives two parameters: function that needs to be called with new password and the reason.
 * @param progressCallback Progress callback.
 * @param concatIntoSingleString If set to true, all of the PDFs pages are concatenated into a
 *   single string and that is returned.
 * @returns A promise that is resolved with an array of each page's text content
 */
export async function readPdfText(
  source:
    | string
    | URL
    | TypedArray
    | PDFDataRangeTransport
    | DocumentInitParameters,
  concatIntoSingleString: true,
  passwordCallback?: (fn: (password: string) => void, reason: string) => string,
  progressCallback?: (progressData: ProgressData) => void
): Promise<string>;
export async function readPdfText(
  source:
    | string
    | URL
    | TypedArray
    | PDFDataRangeTransport
    | DocumentInitParameters,
  concatIntoSingleString?: false | undefined,
  passwordCallback?: (fn: (password: string) => void, reason: string) => string,
  progressCallback?: (progressData: ProgressData) => void
): Promise<Page[]>;
export async function readPdfText(
  source:
    | string
    | URL
    | TypedArray
    | PDFDataRangeTransport
    | DocumentInitParameters,
  concatIntoSingleString?: boolean,
  passwordCallback?: (fn: (password: string) => void, reason: string) => string,
  progressCallback?: (progressData: ProgressData) => void
): Promise<string | Page[]> {
  const documentLoadingTask = getDocument(source);
  if (progressCallback) {
    documentLoadingTask.onProgress = progressCallback;
  }
  if (passwordCallback) {
    documentLoadingTask.onPassword = passwordCallback;
  }

  const document = await documentLoadingTask.promise;

  const pageCount = document.numPages;

  const pages: Page[] = [];

  for (let i = 0; i < pageCount; i++) {
    pages.push(await parsePage(await document.getPage(i + 1)));
  }

  if (concatIntoSingleString) {
    return pages.reduce((accum, page) => {
      return accum.concat(page.lines.join("\n") + "\n");
    }, "");
  } else {
    return pages;
  }
}

async function parsePage(pdfPage: PDFPageProxy) {
  const rawContent = await pdfPage.getTextContent();
  return parsePageItems(
    rawContent.items.filter((item): item is TextItem => "str" in item)
  );
}

/**
 * Parses individual text items generated by pdf.js This allows lower level control of what actually
 * gets parsed. For example, a consumer of this function may remove entire sections of the pdf text
 * prior to passing items in here. See parsePage function above for example usage.
 *
 * @param pdfItems An array of TextItem items.
 */
export function parsePageItems(pdfItems: TextItem[]): Page {
  const lineData: { [y: number]: TextItem[] } = {};

  for (let i = 0; i < pdfItems.length; i++) {
    const item = pdfItems[i];
    const y = item?.transform[5];
    if (!lineData.hasOwnProperty(y)) {
      lineData[y] = [];
    }
    if (item) {
      lineData[y]?.push(item);
    }
  }

  const yCoords = Object.keys(lineData)
    .map((key) => Number(key))
    // b - a here because the bottom is y = 0 so we want that to be last
    .sort((a, b) => b - a)
    // insert an empty line between any 2 lines where their distance is greater than the upper line's height
    .reduce((accum: number[], currentY, index, array) => {
      const nextY = array[index + 1];
      if (nextY != undefined) {
        const currentLine = lineData[currentY]!;
        const currentLineHeight: number = currentLine.reduce(
          (finalValue, current) =>
            finalValue > current.height ? finalValue : current.height,
          -1
        );

        // currentY - nextY because currentY will be higher than nextY
        if (Math.floor((currentY - nextY) / currentLineHeight) > 1) {
          const newY = currentY - currentLineHeight;
          lineData[newY] = [];
          return accum.concat(currentY, newY);
        }
      }
      return accum.concat(currentY);
    }, []);

  const lines: string[][] = [];
  for (let i = 0; i < yCoords.length; i++) {
    const y = yCoords[i];
    if (y == undefined) {
      continue;
    }
    // sort by x position (position in line)
    const lineItems = lineData[y]!.sort(
      (a, b) => a.transform[4] - b.transform[4]
    ).filter((item) => !!item.str);
    const firstLineItem = lineItems[0]!;
    let line = lineItems.length ? [firstLineItem.str] : [""];
    for (let j = 1; j < lineItems.length; j++) {
      const item = lineItems[j]!;
      const lastItem = lineItems[j - 1]!;
      const xDiff =
        item.transform[4] - (lastItem.transform[4] + lastItem.width);

      // insert spaces for items that are far apart horizontally
      if (
        item.height !== 0 &&
        lastItem.height !== 0 &&
        (xDiff > item.height || xDiff > lastItem.height)
      ) {
        const spaceCountA = Math.ceil(xDiff / item.height);
        let spaceCount = spaceCountA;
        if (lastItem.height !== item.height) {
          const spaceCountB = Math.ceil(xDiff / lastItem.height);
          spaceCount = spaceCountA > spaceCountB ? spaceCountA : spaceCountB;
        }
        line.push(""); //+= Array(spaceCount).fill('').join(' ');
      }
      line[line.length - 1] += item.str;
    }
    lines.push(line);
  }

  return {
    lines,
  };
}
